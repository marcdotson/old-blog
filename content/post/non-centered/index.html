---
title: "Non-centered parameterization for hierarchical models"
author: "Marc Dotson"
date: '2020-05-15'
slug: non-centered
---



<p>In a <a href="https://www.occasionaldivergences.com/post/stan-hierarchical/">previous post</a>, we provided a gentle introduction to hierarchical Bayesian models in Stan. We quickly ran into divergences (i.e., divergent transitions) when attempting to estimate our model. While hierarchical models inherently have <a href="https://arxiv.org/abs/1312.0906">posteriors with geometry that can be difficult to navigate</a>, we were able to initially address this problem by more carefully navigating the posterior with a smaller step size.</p>
<p>However, as a hierarchical model becomes more complicated, we need to re-express it in a way that is mathematically equivalent yet results in a posterior that is easier to navigate. We ended that previous post without relaxing the assumption of a common variance in the upper-level population model. In this post, we will build a hierarchical linear model with a multivariate population model. This added complexity will require us to re-express the model using what is known as a non-centered parameterization. Since this more flexible population model specification is standard, so should a non-centered parameterization be our default approach in most applications. Once again, I am in debt to Michael Betancourt’s <a href="https://betanalpha.github.io/writing/">case studies</a>, Richard McElreath’s <a href="https://xcelab.net/rm/statistical-rethinking/"><em>Statistical Rethinking</em></a>, and the <a href="https://mc-stan.org/docs/2_23/stan-users-guide/index.html">Stan User’s Guide</a>.</p>
<div id="multivariate-population-model" class="section level2">
<h2>Multivariate population model</h2>
<p>Recall that the motivation for hierarchical models is to allow for differences across groups while employing partial pooling, striking a balance between no pooling and complete pooling. However, so far we have assumed a common variance in the population model, limiting how much partial information pooling is possible. By moving to a multivariate population model, we allow for more partial information pooling, where each group-level parameter probability can now be associated with every other group-level parameter probability.</p>
<p>Covariance matrices can be difficult to work with, especially when it comes to setting a prior (or, in our case, a hyperprior). A popular approach is to break down the covariance matrix into component pieces. Perhaps the most intuitive decomposition is to break down the covariance matrix into variances and a correlation matrix. If we have a covariance matrix <code>Sigma</code>, this decomposition works as follows:</p>
<pre><code>Sigma = diag_matrix(tau) * Omega * diag_matrix(tau)</code></pre>
<p>where <code>tau</code> is a vector of scale parameters and <code>Omega</code> is a correlation matrix. Not only is this decomposition computationally more tractable, but it allows us to set a prior on <code>tau</code> and <code>Omega</code> separately rather than on <code>Sigma</code> directly.</p>
<p>What does this model look like in Stan?</p>
<pre class="stan"><code>// Index values, observations, and covariates.
data {
  int&lt;lower = 1&gt; N;               // Number of observations.
  int&lt;lower = 1&gt; K;               // Number of groups.
  int&lt;lower = 1&gt; I;               // Number of observation-level covariates.
  int&lt;lower = 1&gt; J;               // Number of population-level covariates.

  vector[N] y;                    // Vector of observations.
  int&lt;lower = 1, upper = K&gt; g[N]; // Vector of group assignments.
  matrix[N, I] X;                 // Matrix of observation-level covariates.
  matrix[K, J] Z;                 // Matrix of population-level covariates.
}

// Parameters and hyperparameters.
parameters {
  matrix[J, I] Gamma;             // Matrix of population-level coefficients.
  corr_matrix[I] Omega;           // Correlation matrix for the population model.
  vector&lt;lower = 0&gt;[I] tau;       // Vector of scale parameters for the population model.
  matrix[K, I] Beta;              // Matrix of observation-level coefficients.
  real&lt;lower = 0&gt; sigma;          // Variance of the likelihood.
}

// Hierarchical regression.
model {
  // Hyperpriors.
  for (j in 1:J) {
    Gamma[j,] ~ normal(0, 5);
  }
  Omega ~ lkj_corr(2);
  tau ~ normal(0, 5);

  // Prior.
  sigma ~ normal(0, 5);

  // Population model and likelihood.
  for (k in 1:K) {
    Beta[k,] ~ multi_normal(Z[k,] * Gamma, quad_form_diag(Omega, tau));
  }
  for (n in 1:N) {
    y[n] ~ normal(X[n,] * Beta[g[n],]&#39;, sigma);
  }
}

// Quantities conditioned on parameter draws.
generated quantities {
  // Log likelihood to estimate loo.
  vector[N] log_lik;
  for (n in 1:N) {
    log_lik[n] = normal_lpdf(y[n] | X[n,] * Beta[g[n],]&#39;, sigma);
  }
}</code></pre>
<p>We’ll save this Stan script of a hierarchical linear model as <code>hlm_centered.stan</code> (we’ll explain the “centered” part shortly). In the <code>parameters</code> block, we now have a correlation matrix <code>Omega</code> and <code>tau</code> is now a vector of scale parameters rather than a scalar. In the <code>models</code> block, <code>Omega</code> is distributed according to the LKJ distribution, a Beta-like distribution for correlation matrices. Additionally, <code>Beta</code> is now distributed multivariate normal, with the covariance matrix a recombination of <code>Omega</code> and <code>tau</code> as described above.</p>
<p>Since all Bayesian models are generative, we can translate this Stan script, , into <code>data</code> and <code>generated quantities</code> to use Stan to generate data for us.</p>
<pre class="stan"><code>// Index values, covariates, and hyperparameter values.
data {
  int&lt;lower = 1&gt; N;               // Number of observations.
  int&lt;lower = 1&gt; K;               // Number of groups.
  int&lt;lower = 1&gt; I;               // Number of observation-level covariates.
  int&lt;lower = 1&gt; J;               // Number of population-level covariates.

  int&lt;lower = 1, upper = K&gt; g[N]; // Vector of group assignments.
  matrix[N, I] X;                 // Matrix of observation-level covariates.
  matrix[K, J] Z;                 // Matrix of population-level covariates.
}

// Generate data according to the hierarchical regression.
generated quantities {
  vector[N] y;                    // Vector of observations.
  matrix[J, I] Gamma;             // Matrix of population-level coefficients.
  corr_matrix[I] Omega;           // Correlation matrix for the population model.
  vector[I] tau;                  // Vector of scale parameters for the population model.
  matrix[K, I] Beta;              // Matrix of group-level coefficients.
  real&lt;lower = 0&gt; sigma;          // Variance of the likelihood.

  // Draw parameter values and generate data.
  for (j in 1:J) {
    for (i in 1:I) {
      Gamma[j, i] = normal_rng(0, 5);
    }
  }
  Omega = lkj_corr_rng(I, 2);
  for (i in 1:I) {
    tau[i] = chi_square_rng(2);
  }
  for (k in 1:K) {
    Beta[k,] = multi_normal_rng(Z[k,] * Gamma, quad_form_diag(Omega, tau))&#39;;
  }
  sigma = normal_rng(0, 5);
  for (n in 1:N) {
    y[n] = normal_rng(X[n,] * Beta[g[n],]&#39;, sigma);
  }
}</code></pre>
<p>We call this Stan script <code>generate_data.stan</code>. Note:</p>
<ul>
<li>Generate parameter values, including LKJ prior.</li>
<li>Transpose multivariate normal draw.</li>
</ul>
<p>In an R script, let’s load the necessary packages, allow Stan to use as many cores as we have available, allow for Stan to save compiled code, specify assumed parameter values, and generate data according to our hierarchical linear model by calling <code>generate_data.stan</code>.</p>
<pre class="r"><code># Load packages.
library(tidyverse)
library(rstan)
library(bayesplot)
library(tidybayes)

# Set Stan options.
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)

# Specify data and hyperparameter values.
sim_values &lt;- list(
  N = 500,                            # Number of observations.
  K = 5,                              # Number of groups.
  I = 7,                              # Number of observation-level covariates.
  J = 3,                              # Number of population-level covariates.

  # Matrix of observation-level covariates.
  X = cbind(
    rep(1, 500),
    matrix(runif(500 * (7 - 1), min = 1, max = 10), nrow = 500)
  ),

  # Matrix of population-level covariates.
  Z = cbind(
    rep(1, 5),
    matrix(runif(5 * (3 - 1), min = 2, max = 5), nrow = 5)
  ),

  # Vector of group assignments.
  g = sample(5, 500, replace = TRUE)
)

# Generate data.
sim_data &lt;- stan(
  file = here::here(&quot;content&quot;, &quot;post&quot;, &quot;non-centered&quot;, &quot;Code&quot;, &quot;generate_data.stan&quot;),
  data = sim_values,
  iter = 1,
  chains = 1,
  seed = 42,
  algorithm = &quot;Fixed_param&quot;
)

# Extract simulated data and parameters.
sim_y &lt;- extract(sim_data)$y
sim_Gamma &lt;- extract(sim_data)$Gamma
sim_Omega &lt;- extract(sim_data)$Omega
sim_tau &lt;- extract(sim_data)$tau
sim_Beta &lt;- extract(sim_data)$Beta
sim_sigma &lt;- extract(sim_data)$sigma

data &lt;- list(
  N = sim_values$N,     # Number of observations.
  K = sim_values$K,     # Number of groups.
  I = sim_values$I,     # Number of observation-level covariates.
  J = sim_values$J,     # Number of population-level covariates.
  y = as.vector(sim_y), # Vector of observations.
  g = sim_values$g,     # Vector of group assignments.
  X = sim_values$X,     # Matrix of observation-level covariates.
  Z = sim_values$Z      # Matrix of population-level covariates.
)

fit_centered &lt;- stan(
  file = here::here(&quot;content&quot;, &quot;post&quot;, &quot;non-centered&quot;, &quot;Code&quot;, &quot;hlm_centered.stan&quot;),
  data = data,
  control = list(adapt_delta = 0.99),
  seed = 42
)</code></pre>
<p>Running this model gives us an excess of 3,500 divergent transitions…</p>
</div>
<div id="non-centered-parameterization" class="section level2">
<h2>Non-centered parameterization</h2>
<p>The standard centered parameterization for a simple hierarchical regression has a population model and likelihood:</p>
<pre><code>beta ~ normal(mu, tau)
y ~ normal(beta, sigma)</code></pre>
<p>where we get draws from the posterior distribution of <code>mu</code> and <code>tau</code>, the population mean and variance, and <code>beta</code>, the group-level intercepts.</p>
<p>A non-centered parameterization re-expresses the population model and likelihood for a simple hierarchical regression as:</p>
<pre><code>delta ~ normal(0, 1)
beta = mu + tau * delta
y ~ normal(beta, sigma)</code></pre>
<p>where we get draws from the posterior distribution of <code>mu</code>, <code>tau</code>, and <code>delta</code>, since <code>beta</code> is now a fixed transformation of the other parameters (i.e., we have <code>beta =</code> instead of <code>beta ~</code>). The benefit of a non-centered parameterization – the inclusion of the intermediate <code>delta</code> and the fixed transformation of <code>beta</code> – is that difficult dependencies between the two layers in the hierarchy are broken, producing a simpler posterior geometry.</p>
<pre class="stan"><code></code></pre>
<div id="simple-hierarchical-regression" class="section level3">
<h3>Simple hierarchical regression</h3>
<p>Let’s start by demonstrating how to implement a non-centered parameterization for a simple hierarchical regression.</p>
<pre class="stan"><code>// Index values and observations.
data {
  int&lt;lower = 1&gt; N;               // Number of observations.
  int&lt;lower = 1&gt; K;               // Number of groups.
  vector[N] y;                    // Vector of observations.
  int&lt;lower = 1, upper = K&gt; g[N]; // Vector of group assignments.
}

// Parameters and hyperparameters.
parameters {
  real mu;                        // Mean of the population model.
  real&lt;lower = 0&gt; tau;            // Variance of the population model.
  vector[K] delta;                // Vector of non-centered group intercepts.
  real&lt;lower = 0&gt; sigma;          // Variance of the likelihood.
}

// Deterministic transformation.
transformed parameters {
  // Vector of transformed group intercepts.
  vector[K] beta;

  // Non-centered parameterization.
  for (k in 1:K) {
    beta[k] = mu + tau * delta[k];
  }
}

// Hierarchical regression.
model {
  // Hyperpriors.
  mu ~ normal(0, 5);
  tau ~ normal(0, 5);

  // Prior.
  sigma ~ normal(0, 5);

  // Non-centered population model and likelihood.
  for (k in 1:K) {
    delta[k] ~ normal(0, 1);
  }
  for (n in 1:N) {
    y[n] ~ normal(beta[g[n]], sigma);
  }
}</code></pre>
<p>Instead of <code>beta</code>, we include <code>delta</code> in the <code>parameters</code> block, noted here as the non-centered group intercepts. To impose the deterministic transformation, we include a <code>transformed parameters</code> block, which includes both <code>beta</code> and the non-centered transformation itself <code>beta[k] = mu + tau * delta[k]</code>. Finally, in place of <code>beta</code>, the non-centered population model <code>delta[k] ~ normal(0, 1)</code> is included in the <code>model</code> block.</p>
</div>
<div id="multiple-hierarchical-regression" class="section level3">
<h3>Multiple hierarchical regression</h3>
<p>Note that the need to break difficult dependencies between the two layers in the hierarchy grows with thinner data or more dimensions introduced with covariates. However, the centered and non-centered parameterizations are inversely related in terms of efficiency; when a centered parameterization will suffice, a non-centered parameterization should underperform and when a non-centered parameterization will suffice, a centered parameterization should underperform.</p>
<p>Conclude with a discussion on efficiency…</p>
<ul>
<li><p>Respond to Stan Discourse reply and include variance parameters (reference Stan User’s Guide).</p></li>
<li><p>Plot Delta on tau to see where the divergences are appearing (may need to run longer chains to get better plots).</p></li>
<li><p>Worry about indexing efficiency (i.e., arrays instead of matrices)? Pre-computing X’Beta with a local variable assignment? See Stan User’s Guide on Hierarchical Logistic Regression.</p></li>
<li><p>Look at implementation for HMNL?</p></li>
<li><p>Under what conditions does NCP &gt; CP? CP &gt; NCP?</p></li>
<li><p>Adding lower-level covariates <code>X</code> – why does this break NCP?</p></li>
<li><p>Adding upper-level covariates <code>Z</code> – why does this break NCP?</p></li>
</ul>
<hr />
</div>
<div id="marc-dotson" class="section level3">
<h3>Marc Dotson</h3>
<p>Marc is an assistant professor of marketing at the BYU Marriott School of Business. He graduated with an MSc from The London School of Economics and Political Science in 2009 and a PhD from The Ohio State University in 2016. His research interests include Bayesian inference, predictive modeling, consumer preference heterogeneity, and unstructured data. Marc teaches marketing analytics. You can find him on <a href="https://twitter.com/marcdotson">Twitter</a> and <a href="https://github.com/marcdotson">GitHub</a>.</p>
</div>
</div>
