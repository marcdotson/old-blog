---
title: Hierarchical models in Stan
author: Marc Dotson
date: '2019-08-27'
slug: stan-hierarchical
categories: []
tags: []
Categories:
  - R
  - Stan
  - Tidyverse
Description: ''
Tags:
  - 
---



<p>Bayesian inference provides an intuitive and self-consistent approach to statistical modeling. In short, you have beliefs about unobserved values (e.g., the impact of price on customer satisfaction) and you use data to update those beliefs. The barrier to using Bayesian inference in practice has never been this intuition – it’s been the <a href="https://arxiv.org/abs/1701.02434">required computation</a>. There has been a great deal of progress on this front, with <a href="https://mc-stan.org">Stan</a> arguably providing the best solution.</p>
<p>Stan is a probabilistic programming language that provides a general-purpose sampler using Hamiltonian Monte Carlo. In other words, Stan automates the required computation (for many models), allowing you to conduct Bayesian inference by just focusing on model building. This is especially powerful when it comes to utilizing the mainstay of Bayesian inference: hierarchical models.</p>
<p>The goal of this post is to provide a bridge to building hierarchical models using Stan and R. We’ll start with a very brief introduction to Stan and build in complexity from there. This post does not provide a general introduction to Bayesian inference or Stan. See:</p>
<ul>
<li>Introduction to Bayesian inference</li>
<li>Introduction to Stan</li>
</ul>
<div id="simple-regression" class="section level2">
<h2>Simple regression</h2>
<p>Let’s start with a simple (non-hierarchical) regression. In a Stan script, which <a href="https://blog.rstudio.com/2018/10/16/rstudio-1-2-preview-stan/">has native support in RStudio</a>, we specify the three required blocks for a Stan model: <code>data</code>; <code>parameters</code>, the unobserved values we want to estimate; and <code>model</code>, both the prior and likelihood.</p>
<pre class="stan"><code>// Index value and observations.
data {
  int&lt;lower = 1&gt; N;  // Number of individuals.
  vector[N] y;       // Vector of observations.
}

// Parameters.
parameters {
  real mu;           // Mean of the regression.
  real&lt;lower=0&gt; tau; // Variance of the regression.
}

// Simple regression.
model {
  // Priors.
  mu ~ normal(0, 5);
  tau ~ normal(0, 5);

  // Likelihood.
  y ~ normal(mu, tau);
}</code></pre>
<p>Imagine this is a model of customer satisfaction where we have <code>N</code> individuals, the overall satisfaction <code>y</code> from each individual, and we are assuming that satisfaction <code>y</code> is distributed <code>normal</code>, with a single mean <code>mu</code> and variance <code>tau</code> to describe customer satisfaction in the population.</p>
<p>Like all Bayesian models, this model is fully generative, so we can also use Stan to generate data according to some assumed parameter values and then use the generated data to test the model, including demonstrating parameter recovery. To do this, we reorganize these three blocks into <code>data</code> (which now includes the assumed parameter values) and <code>generated quantities</code> blocks.</p>
<pre class="stan"><code>// Index and parameter values.
data {
  int&lt;lower = 1&gt; N;  // Number of observations.
  real mu;           // Mean of the regression.
  real&lt;lower=0&gt; tau; // Variance of the regression.
}

// Generate data according to the simple regression.
generated quantities {
  vector[N] y;       // Vector of observations.

  // Generate data.
  for (n in 1:N) {
    y[n] = normal_rng(mu, tau);
  }
}</code></pre>
<p>The for loop over <code>y</code> in the <code>generated quantities</code> block emphasizes the strong assumption of this non-hierarchical model that a single mean <code>mu</code> and variance <code>tau</code> describe customer satisfaction in the population. We’ll return to this shortly.</p>
<p>In an R script, let’s load the necessary packages, allow Stan to use as many cores as we have available, specify assumed parameter values, and generate data according to our simple regression.</p>
<pre class="r"><code># Load packages.
library(tidyverse)
library(rstan)
library(bayesplot)
library(tidybayes)

# Set Stan options.
options(mc.cores = parallel::detectCores())

# Specify data and parameter values.
sim_values &lt;- list(
  N = 100, # Number of observations.
  mu = 5,  # Mean of the regression.
  tau = 3  # Variance of the regression.
)

# Generate data.
sim_data &lt;- stan(
  file = here::here(&quot;content&quot;, &quot;post&quot;, &quot;stan-hierarchical&quot;, &quot;code&quot;, &quot;generate_data.stan&quot;),
  data = sim_values,
  iter = 1,
  chains = 1,
  seed = 42,
  algorithm = &quot;Fixed_param&quot;
)

# Extract simulated data.
sim_y &lt;- extract(sim_data)$y</code></pre>
<p>To test our model, we simply specify the generated data inputs as a list, call the regression model from R, and Stan does all the heavy lifting for us.</p>
<pre class="r"><code># Specify data.
data &lt;- list(
  N = length(sim_y),   # Number of individuals.
  y = as.vector(sim_y) # Vector of observations.
)

# Calibrate the model.
fit &lt;- stan(
  file = here::here(&quot;content&quot;, &quot;post&quot;, &quot;stan-hierarchical&quot;, &quot;code&quot;, &quot;regression.stan&quot;),
  data = data,
  seed = 42
)</code></pre>
<p>Note that we aren’t calling <code>generate_data.stan</code>, we’re calling <code>regression.stan</code> (the model with the three required blocks).</p>
<p>Once the model has finished running, we can check diagnostics, including checking for divergences, which are unique to using Hamiltonian Monte Carlo.</p>
<pre class="r"><code># Diagnostics.
source(here::here(&quot;content&quot;, &quot;post&quot;, &quot;stan-hierarchical&quot;, &quot;code&quot;, &quot;stan_utility.R&quot;))
check_all_diagnostics(fit)</code></pre>
<pre><code>[1] &quot;n_eff / iter looks reasonable for all parameters&quot;
[1] &quot;Rhat looks reasonable for all parameters&quot;
[1] &quot;0 of 4000 iterations ended with a divergence (0%)&quot;
[1] &quot;0 of 4000 iterations saturated the maximum tree depth of 10 (0%)&quot;
[1] &quot;E-FMI indicated no pathological behavior&quot;</code></pre>
<p>The diagnostics check out. We can also check the trace plots and, to be thorough, plot the marginal posteriors for our parameter values to confirm that the assumed parameter values used when generating data are within the 95% credible intervals.</p>
<pre class="r"><code># Check trace plots.
fit %&gt;%
  mcmc_trace(
    pars = c(&quot;mu&quot;, &quot;tau&quot;),
    n_warmup = 500,
    facet_args = list(nrow = 2, labeller = label_parsed)
  )</code></pre>
<p><img src="figures/mcmc_trace.png" /></p>
<p>As suggested by the <code>Rhat</code> diagnostic, we have good mixing and clear convergence for both of our model parameters.</p>
<pre class="r"><code># Recover parameter values.
par_values &lt;- tibble(
  .variable = c(&quot;mu&quot;, &quot;tau&quot;),
  values = c(sim_values$mu, sim_values$tau),
)

fit %&gt;%
  gather_draws(mu, tau) %&gt;%
  ggplot(aes(x = .value, y = .variable)) +
  geom_halfeyeh(.width = .95) +
  facet_wrap(
    ~ .variable,
    nrow = 2,
    scales = &quot;free&quot;
  ) +
  geom_vline(aes(xintercept = values), par_values, color = &quot;red&quot;)</code></pre>
<p><img src="figures/marginals.png" /></p>
<p>The assumed parameter values have been recovered by the model! In summary, we’ve generated data and demonstrated that the model is working as intended.</p>
</div>
<div id="simple-hierarchical-regression" class="section level2">
<h2>Simple hierarchical regression</h2>
<p>So why move to a hierarchical model? A hierarchical model accounts for structure in our data.</p>
<p>If we are estimating the preferences of consumers, we know that consumers preferences are different. This heterogeneity makes the use of a standard linear model incredibly problematic, since that model assumes that preferences are shared across consumers. Just as hierarchical models account for consumer heterogeneity in models of preference, they similarly account for existing hierarchies in other applications and should be considered the default model rather than aggregate models.</p>
<p>Hierarchical models should be our default approach in most applications and Stan removes the barriers to entry for Bayesian computation. However, there are behaviors inherent to hierarchical models that make them somewhat problematic to implement in Stan. This can provide a frustrating mismatch: Providing a way into Bayesian inference only to pull it away again. The motivation for this post is to provide a gentle introduction into implementing hierarchical models in Stan.</p>
</div>
<div id="benefits" class="section level2">
<h2>Benefits</h2>
<ul>
<li>Partial pooling (like shrinking, adaptively between an aggregate model and separate models, which helps avoid overfitting).</li>
<li>Estimate both individual and population parameters simultaneously.</li>
<li>Include information in the form of covariates at both individual and population levels.</li>
<li>Exploit the (frequently present) hierarchical structure in the data.</li>
</ul>
</div>
<div id="difficulties" class="section level2">
<h2>Difficulties</h2>
<p>The correlations induced within a hierarchical model change the geometry sufficiently as to make their estimation via Hamiltonian Monte Carlo more challenging than the geometry of an aggregate model. Don’t throw the baby out with the bathwater – these same problems exist for other samplers as well, though they might not be as obvious, and HMC promises to still provide a more efficient and complete sampling of the posterior distribution as long as we know how to navigate their implementation.</p>
<ul>
<li>Illustrate a hierarchical model (see Michael’s hierarchical regression or expand my own tidy Bayesian workflow example into a hierarchical linear model [same thing?]).</li>
<li>Geometry of hierarchical models.</li>
<li>Parameterizations (centered vs. non-centered).</li>
<li>Diagnostics (what’s the deal with NaN’s? how do we really compute Rhat?).</li>
</ul>
</div>
<div id="stages" class="section level2">
<h2>Stages</h2>
<ul>
<li>Simple hierarchical regression, where we have varying-intercepts only.</li>
<li>Multiple hierarchical regression, where we have varying-intercepts and varying-slopes.</li>
<li>General hierarchical regression, where we have multiple observations and deal with estimable variance.</li>
</ul>
</div>
